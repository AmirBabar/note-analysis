-- Schema Migration for Google Embeddings with Chunking
-- Run this in your Supabase SQL Editor to migrate from the old schema to the new chunked schema

-- Drop the old table if it exists (we're starting fresh)
DROP TABLE IF EXISTS public.clinical_notes_embeddings CASCADE;

-- Drop the old view if it exists
DROP VIEW IF EXISTS public.clinical_notes_summary;

-- Create the new clinical_notes_embeddings table with chunking support
CREATE TABLE public.clinical_notes_embeddings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  note_id TEXT NOT NULL,
  patient_id TEXT NOT NULL,
  chunk_index INTEGER DEFAULT 0,
  content TEXT NOT NULL,
  embedding vector(768), -- For Google text-embedding-004 (768 dimensions)
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add indexes for better performance
CREATE INDEX idx_clinical_notes_embeddings_note_id ON public.clinical_notes_embeddings(note_id);
CREATE INDEX idx_clinical_notes_embeddings_patient_id ON public.clinical_notes_embeddings(patient_id);
CREATE INDEX idx_clinical_notes_embeddings_chunk_index ON public.clinical_notes_embeddings(chunk_index);
CREATE INDEX idx_clinical_notes_embeddings_metadata_gin ON public.clinical_notes_embeddings USING gin(metadata);

-- Add unique constraint on note_id + chunk_index
ALTER TABLE clinical_notes_embeddings ADD CONSTRAINT unique_note_chunk UNIQUE (note_id, chunk_index);

-- Create a vector index for similarity search (HNSW index for faster vector similarity search)
CREATE INDEX idx_clinical_notes_embeddings_embedding_cosine
ON public.clinical_notes_embeddings
USING hnsw (embedding vector_cosine_ops);

-- Enable Row Level Security (RLS)
ALTER TABLE public.clinical_notes_embeddings ENABLE ROW LEVEL SECURITY;

-- Create RLS policies (adjust as needed for your security requirements)
-- Policy to allow authenticated users to read embeddings
CREATE POLICY "Allow authenticated users to read clinical notes embeddings"
ON public.clinical_notes_embeddings FOR SELECT
USING (auth.role() = 'authenticated');

-- Policy to allow service role to insert/update embeddings
CREATE POLICY "Allow service role to manage clinical notes embeddings"
ON public.clinical_notes_embeddings FOR ALL
USING (auth.role() = 'service_role')
WITH CHECK (auth.role() = 'service_role');

-- Create a function for automatic updated_at timestamp
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically update updated_at
CREATE TRIGGER handle_clinical_notes_embeddings_updated_at
BEFORE UPDATE ON public.clinical_notes_embeddings
FOR EACH ROW
EXECUTE FUNCTION public.handle_updated_at();

-- Grant permissions
GRANT ALL ON public.clinical_notes_embeddings TO service_role;
GRANT SELECT ON public.clinical_notes_embeddings TO authenticated;
GRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;

-- Create a view for easier querying
CREATE OR REPLACE VIEW public.clinical_notes_summary AS
SELECT
    note_id,
    patient_id,
    COUNT(*) as total_chunks,
    MIN(chunk_index) as first_chunk,
    MAX(chunk_index) as last_chunk,
    (metadata->>'note_type') as note_type,
    (metadata->>'note_date') as note_date,
    (metadata->>'provider') as provider,
    (metadata->>'organization') as organization,
    (metadata->>'source_file') as source_file,
    (metadata->>'parent_note_id') as parent_note_id,
    MIN(created_at) as first_created,
    MAX(updated_at) as last_updated
FROM public.clinical_notes_embeddings
GROUP BY note_id, patient_id, metadata;

-- Grant permissions on the view
GRANT SELECT ON public.clinical_notes_summary TO authenticated, anon;